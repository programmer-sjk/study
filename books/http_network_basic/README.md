# 1장. 웹과 네트워크의 기본에 대해 알아보자.
## 1.3 네트워크의 기본은 TCP/IP
+ 컴퓨터와 네트워크 기기가 상호간에 통신하기 위해서는 서로 같은 방법으로 통신해야 하는데 이런 규칙을 프로토콜이라 부른다.
+ TCP/IP에서 중요한 개념 중 하나가 계층이다. 계층화 된 것은 메리트가 있는데, 인터넷이 하나의 프로토콜로 되어 있다면
사양이 변경되었을 때 전체를 바꿔야 하지만 계층화 되어 있다면 변경된 계층만 바꾸면 된다.
+ TCP/IP로 통신을 할 때 계층을 순서대로 거쳐 상대와 통신을 한다. 송신측에서 각 계층을 거칠 때는 해당 계층마다 필요한
헤더를 추가한다. 반대로 수신측에서는 각 계층을 거칠 때마다 해당 계층에서 사용한 헤더를 삭제한다. 이렇게 정보를 감싸는
과정을 캡슐화라고 한다.

## 1.7 URI와 URL
+ URI는 리소스를 식별하기 위한 문자열이고 URL은 리소스의 장소를 나타낸다. URI는 URL을 포함한다.
+ 예를들어 inflearn.com/users는 자원의 위치를 알려주기 때문에 URL이자 URI이고,
  inflearn.com/users/1은 특정 자원을 식별하기 때문에 URI 이다.

# 2장. 간단한 HTTP 프로토콜
## 2.3 HTTP는 상태를 유지하지 않는 프로토콜
+ HTTP는 상태를 유지하지 않는 stateless 프로토콜이다. 이는 많은 데이터를 매우 빠르고 확실하게 처리하기 위해 간단하게 설계되어 있다.
+ 그러나 웹이 진화함에 따라 로그인 상태를 유지하는 등의 문제가 발생했는데, 이 요구에 부응하기 위해 쿠키라는 기술이 도입되었다.

## 2.4 리퀘스트 URI로 리소스를 식별
+ HTTP URI로 인터넷 상의 리소스를 지정할 수 있고 이 URI 덕분에 인터넷 상의 어떤 리소스도 호출 할 수 있다.

## 2.8 쿠키를 사용한 상태관리
+ 쿠키는 서버에서 response로 보내진 Set-Cookie 라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됩니다.
다음 번에 클라이언트가 같은 서버로 request를 보낼 때 자동으로 쿠키 값을 넣어서 송신합니다. 서버는 클라이언트가
보낸 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인해 이전 상태를 알 수 있습니다.

# 3장. HTTP 정보는 HTTP 메시지에 있다.
+ HTTP 메시지는 [메시지 헤더] + [개행문자(CR+LF)] + [메시지 바디] 로 구성된다.

## 3.3 인코딩으로 전송 효율을 높이다.
+ HTTP를 통해 데이터를 그대로 전송할 수도 있지만 인코딩을 통해 전송 효율을 높일 수 있다.
### 압축해서 보내는 콘텐츠 코딩
+ 콘텐츠 코딩은 엔티티에 적용하는 인코딩을 가리키는데, 엔티니 정보를 유지한채 압축한다. 수신한 클라이언트 측에서는 디코딩한다.
### 분해해서 보내는 청크 전송 코딩
+ 사이즈가 큰 데이터를 전송하는 경우 데이터를 분할해서 조금씩 표시할 수 있다. 이렇게 엔티티 바디를 분할하는
기능을 청크 전송 코딩이라고 한다.

# 4장. 상태를 나타내는 HTTP 상태 코드
+ 상태 코드 
```text
2xx -> 리퀘스트를 정상처리함
3xx -> 리퀘스트를 완료하기 위해 추가 동작이 필요 (리다이렉트 같은)
4xx -> 서버는 리퀘스트 이해 불가능
5xx -> 서버는 리퀘스트 처리 실패
```

#5장. HTTP와 연계하는 웹 서버
## 5.1 1대로 멀티 도메인을 가능하게 하는 가상 호스트
+ HTTP/1.1 에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있다.
+ 1대의 서버에 가상 호스트라는 기능을 사용해 물리적으로는 서버가 1대지만 가상으로 여러대가 있는 것처럼 설정하는 것이 가능하다.
+ 인터넷에서 도메인 명은 DNS에 의해 IP 주소로 변환되고 엑세스 된다. 이 때 1대의 서버안에 여러 도메인이 있을 경우 어느쪽에 대한
엑세스인지 알 수가 없다. 따라서 HTTP 리퀘스트를 보내는 경우 호스트명과 도메인명을 완전히 포함한 URI를 지정하거나 
반드시 Host 헤더 필드에서 지정해야 한다.

## 5.2 통신을 중계하는 프로그램: 프록시, 게이트웨이, 터널
### 5.2.1 프록시
+ 프록시 서버의 기본 동작은 클라이언트로 부터 받은 요청을 다른 서버에 전송하고, 서버로부터 받은 응답을 클라이언트에게 전달한다.
+ 리소스 본체를 가진 서버를 오리진 (Origin Server) 서버라고 부른다.
+ 프록시 서버를 사용하는 이유는 캐시를 사용해 네트워크 대역을 효율적으로 사용하는 것과 조직내에 특정 웹 사이트에 대한
엑세스 제한, 엑세스 로그를 획득하는 목적으로 사용한다.
+ 캐싱프록시: 프록시 서버 상에 리소스 캐시를 보존해 두는 타입의 프록시. 같은 리소스에 대한 요청이 온 경우 오리진 서버로부터
리소스를 획득하는 것이 아니라 캐시를 리스폰스로서 되돌려 주는 경우이다.

## 5.3 리소스를 보관하는 캐시
+ 캐시는 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본을 가리킨다.
+ 캐시를 사용하면 리소스를 가진 서버의 엑세스를 줄이는 것이 가능하기 때문에 통신량과 통신시간을 절약할 수 있다.
### 5.3.1 캐시의 유효기간
+ 캐시 서버에 캐시가 있더라도 항상 캐시를 돌려준다고 할 수는 없다. 이것은 캐시되어 있는 리소스의 유효성과 관계가 있다.
+ 항상 같은 캐시를 사용하고 있다보면 오리진 서버에 있는 원래 리소스가 변경되는 경우가 있는데, 이 때 캐시서버는 갱신되기 전의 낡은 리소스를 그대로가지고 있다.
+ 따라서 캐시를 가지고 있더라도 클라이언트의 요구나 캐시의 유효기간 등에 의해서 오리진 서버에 리소스의 유효성을 확인하거나 새로운 리소스를 다시 획득하러 가는 경우가 있다.

#6장. HTTP 헤더
## 6.2 HTTP 헤더 필드
+ HTTP 헤더 필드는 HTTP 메시지를 구성하는 요소의 하나이다. 요청과 응답 모두 사용되며 중요한 정보를
전달하는 역할을 담당하고 있다.

## 6.7 쿠키를 위한 헤더 필드
### secure 속성
+ 쿠키의 secure 속성은 웹 페이지가 HTTPS 에서 열렸을 때에만 쿠키 송출을 제한하기 위해서 지정합니다.
아래와 같이 secure 속성을 지정할 수 있다.
```text
set-cookie: connect.sid=s%3AcX~~; Path=/; 
Expires=Sat, 16 Apr 2022 06:49:08 GMT; HttpOnly; Secure
```
+ 위의 경우, https://test.com 일 때만 쿠키가 전달된다. 즉, 도메인이 같더라도 http://test.com
은 쿠키를 전달하지 않는다. 
+ secure 속성을 생략한 경우는 프로토콜에 상관없이 쿠키를 반송한다.

### httpOnly 속성
+ 이 속성은 JS를 경유해 쿠키를 취득하지 못하도록 막는 것으로 CSS로부터 쿠키 도청을 막는것을 목적으로 한다.
+ 통상 웹 페이지 내에서는 쿠키를 읽어 들일 수 있지만, httpOnly 속성이 부여된 쿠키는 JS의
document.cookie에서는 읽을 수 없게 된다.

#9장. HTTP에 기능을 추가한 프로토콜
+ HTTP 규격이 만들때에 비해 시대는 크게 바뀌고 요구사항이 복잡해지면서 HTTP 프로토콜만으로는
효율성이나 제한이 있음. 그래서 HTTP를 기반으로 해서 기능을 추가한 형태로 몇 가지 프로토콜이 구현됨
## 9.2 HTTP 병목 현상을 해소하는 SPDY
+ 페북이나 트위터 같은 SNS는 수백만명, 수천만 명의 유저가 메시지 정보를 작성하면 그 정보들을
    클라이언트 화면에 반영할 필요가 있다. 허나 HTTP에서는 서버의 정보가 갱신되었는지 클라이언트가 항상
    서버측에 확인하려 가야 한다.
+ 구글이 2010년에 발표한 HTTP의 병목 현상을 해소하고 웹 페이지 로딩 시간을 50% 단축한다는 목표를 세우고 개발중
## 9.3 브라우저에서 양방향 통신을 하는 WebSocket
+ Web Socket은 웹 서버와 클라이언트가 한 번 접속을 확립하면 그 뒤의 통신을 모두 전용 프로토콜로 하는
방식으로 JSON, XML, HTML이나 이미지등의 데이터를 보내게 된다.
+ 접속의 출발점이 클라이언트에 있다는 것은 변함이 없지만, 한 번 접속을 확립하면 서버와 클라이언트 어느 쪽에서도
송신이 가능해진다.
  + 서버 푸쉬 기능
    + 서버에서 클라이언트에 데이터를 푸쉬하는 기능을 제공
  + 통신량의 삭감
    + 접속을 유지하기 때문에 자주 접속을 하는 오버헤드가 적어지고 통신량을 줄일 수 있다.

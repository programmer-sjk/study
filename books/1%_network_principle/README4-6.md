# 4장.엑세스 회선을 통해 인터넷의 내부로!
+ 인터넷의 실체는 한 개의 조직이 운영 관리하는 단일 네트워크가 아니라 다수의 프로바이더의 네트워크를 서로 접속한 것이다.
그리고 ADSL, FTTH의 엑세스 회선은 사용자가 계약한 프로바이더의 설비에 연결되어 있는데 이 설비를 POP라 하며
인터넷의 입구인 라우터는 여기에 설치가 되어 있다.
+ 여기서 프로바이더란 ISP(Internet Service Provider)를 의미하며 국내에는 KT, SK, LG 유플러스 등이 있다.
+ 인터넷의 라우터는 최종 목적지가 동일 프로바이더인지, 다른 프로바이더인지 상관없이 모든 경로가 등록되어 있다. 따라서
라우팅 테이블에서 다음 중계 대상을 찾아 패킷을 보내는 동작을 반복하면 지구 반대편에 패킷을 보내는 것도 가능하다.

# 5장. 서버측의 LAN 앞에는 무엇이 있을까?
## 웹 서버의 설치 장소
+ 인터넷을 빠져나와 서버에 도착할 때까지의 여정은 서버의 설치 장소에 따라 다르다. 사내에 웹 서버를 설치하는 경우는
보통 앞 단에 방화벽을 두어 특정 애플리케이션에 엑세스 하는 패킷만 통과 시키고 그 외의 패킷은 차단 시킨다.
+ 회사 안에 서버를 설치하지 않고 데이터센터에 서버를 설치하거나 프로바이더가 소유하는 서버를 빌려쓰는 형태로 운영하는 경우도 있다.

## 방화벽의 원리와 동작
+ 송/수신처 IP 주소, 송/수신처 포트 번호 TCP 컨트롤 비트를 조건으로 사용하고 애플리케이션의 종류, 엑세스 방향등을 
판별하는 방법으로 패킷을 필터링한다.

## 여러 서버에 리퀘스트를 분배하는 서버의 부하 분산
+ 다수의 사용자가 집중적으로 액세스 하면 서버 한 대로는 따라잡지 못할 수도 있다. 이때는 복수의 서버를 사용하여 처리를 분담하는
방법으로 서버 한 대당 처리량을 줄이는 것이 효과적이며 이를 분산 처리라고 한다.
+ 이를 위해 부하 분산장치 또는 로드밸런서로 불리우는 기기가 고안되었다. 이를 사용할 때는 먼저 웹 서버 대신 DNS 서버에 등록한다.
+ 로드밸런서에 웹 서버가 연상되는 www.cyber.co.kr과 같은 이름을 붙이고 해당 IP를 DNS 서버에 등록한다. 그 이후, 
클라이언트는 로드밸런서가 웹 서버라고 생각하여 로드밸런서에 요청을 전달한다.
+ 로드밸런서는 어느 웹 서버에 요청을 전달할지 판단해야 하는데, 이 요청이 일련의 요청인지 관계가 없는 요청인지 판단해야 한다.
즉 A 서버와 대화가 복수페이지에 걸쳐 있는 요청은 웹 서버의 부하에 관계 없이 이전 웹 서버에게 요청을 전달해야 한다.
+ 전 후 관계를 판단하기 위해, 데이터에 전후 관계를 나타내는 정보를 부가하거나, HTTP 사양을 확장하여 전후 관계를 판단하기 위한
헤더 필드를 부가하는 방법이다. 로드밸런서는 이러한 정보를 조사하여 일련의 동작이라면 이전과 같은 웹 서버에 요청을 전달하고 
그렇지 않으면 부하가 적은 웹 서버에 요청을 전송하도록 동작한다.

## 캐시 서버를 이용한 서버의 부하 분산
+ 같은 기능의 여러 서버를 설치하는 것이 아니라 다른 방법으로 부하 분산을 하는 방법이 있다. 이중 하나가 캐시 서버를 사용하는 방법
+ 캐시 서버는 웹 서버와 클라이언트 사이에 들어가서 프록시 역할을 하여 액세스 동작을 중개한다. 액세스 동작을 중개할 때 웹 서버에서
받은 데이터를 디스크에 저장해두고 웹 서버를 대신하여 데이터를 클라이언트에게 반송한다.
+ 웹 서버는 DB 조회 등, 데이터를 응답할 때 다소 시간이 걸리는데, 캐시는 받아둔 데이터를 읽어서 송신만 하면 되므로 웹 서버보다
빠르게 데이터를 송신할 수 있다.
+ 캐시 서버를 사용할 때는 캐시 서버를 웹 서버 대신 DNS에 등록한다. 캐시 서버에 데이터가 없는 경우 웹 서버로부터 데이터를 수신
받아 캐시에 저장하고 클라이언트에게 응답합니다. 캐시에 데이터가 있을 경우, 웹 서버측의 데이터 변경이 있었는지 조사하기 위해
if-Modified-Since 헤더필드를 추가하여 웹 서버에 전송합니다. 웹 서버는 헤더필드의 값과 데이터의 최종 갱신 일시를 비교하여
변경이 없으면 변경이 없는 것을 나타내는 응답 메시지를 반송한다. 이때 웹 서버는 데이터의 최종 갱신 일시를 조사하는 것으로 끝나므로
데이터 전체를 응답하는 것보다 부담이 적어진다. 만약 웹 서버측의 데이터가 변경된 경우에, 웹 서버는 최신 데이터를 반송하고
캐시 서버는 이 데이터를 캐시에 저장한다.

## 콘텐츠 배포 서비스
+ 캐시 서버를 서버측에 두면 웹 서버의 부하를 경감하는 효과는 있지만 트래픽을 억제하는 효과는 없고,
클라이언트에 캐시 서버가 있으면 패킷의 흐름이 안정화되지만 클라이언트측 네트워크 소유이므로 웹 서버 운영자가 제어할 수 없습니다.
+ 이에 따라 클라이언트 측에 캐시 서버를 설치하고, 이것을 웹 서버 운영자에게 대출하는 서비스를 제공하는 사업자가 등장했는데 이런 종류의
서비스를 컨텐츠 배포 서비스(CDS or CDN)라고 합니다. 
+ 이 서비스를 제공하는 사업자는 주요한 프로바이더와 계약하고 그곳에 다수의 캐시 서버를 설치합니다. 이 사업자는 또한 웹 서버 운영자와도
계약하여 웹 서버와 캐시 서버를 연계시킵니다.
+ CDN을 사용하는 경우, 다수의 캐시 서버 중에서 가장 가까운 캐시 서버를 찾아내고 클라이언트가 여기에 액세스 하도록
중재하는 구조가 필요. 이를 위해 DNS 서버가 웹 서버의 IP 주소를 회답할 때 가장 가까운 캐시 서버의 IP주소를 응답하도록 DNS
서버를 설정한다. 이때의 요점은 클라이언트와 캐시 서버의 거리를 판단하여 클라이언트에 가장 가까운 캐시 서버의 IP주소를 응답하도록 한다.
+ 이 과정에서 라우팅 테이블을 사용하여 클라이언트와 캐시 서버와의 거리를 알아낼 수 있으며 정확한 거리를 측정하지는 못하지만
웬만큼 정확하게 거리를 측정할 수 있다.

# 6장. 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다.
## 서버 애플리케이션의 구조
+ 서버는 클라이언트가 접속할 수 있는 여러개의 소켓을 만들어 놓고, 접속을 기다리게 된다.
+ 데이터 송/수신의 동작을 보았을 때 클라이언트와 서버의 차이점은, 접속하는 측이 클라이언트이고 접속을 기다리는 측이 서버가 된다.
+ 클라이언트측의 단계는 아래와 같다.
```text
소켓을 만든다. (소켓 생성)
서버측의 소켓을 파이프로 연결한다. (접속)
데이터를 송/수신한다. (송/수신)
파이프를 분리하고 소켓을 제거한다. (연결 끊기)
```
+ 서버측의 단계는 아래와 같다.
```text
소켓을 만든다. (소켓 생성)
소켓을 접속 대기 상태로 만든다. (접속 대기 상태)
클라이언트의 접속을 접수한다. (접속 접수 상태)
데이터를 송/수신한다. (송/수신)
파이프를 분리하고 소켓을 제거한다. (연결 끊기)
```

## 서버의 수신동작
+ 수신 동작은 패킷의 빛의 신호를 LAN 어댑터에서 수신하고 디지털 데이터로 바꾸는 부분에서 시작된다.
+ LAN 어댑터의 MAC 부분이 패킷을 신호로부터 디지털 데이터로 되돌리고 버퍼 메모리에 저장한다.
+ 그 사이 서버의 CPU는 다른 일을 하고 있으므로 패킷을 알아차리지 못한다. 따라서 LAN 어댑터에서
인터럽트를 발생시켜 CPU에게 패킷의 도착을 알린다. CPU는 실행하던 작업을 중단하고 LAN 드라이버를 실행.
+ LAN 드라이버는 LAN 어댑터의 버퍼 메모리에서 수신한 패킷을 추출하고 TCP/IP 프로토콜 스택을
호출하고 여기에 패킷을 건네준다.
+ IP 담당은 IP 헤더의 내용이 규칙에 따라 작성되었는지 점검 후, 수신자 IP가 자신이 맞는지 확인후
TCP 담당에게 건네준다.
+ TCP 담당은 도착한 패킷으로부터 어느 소켓이 연결되어 있는지를 찾고, 소켓에 기록된 데이터 송/수신의
진행상황과 도착한 패킷의 TCP 헤더 정보를 결합하여 데이터 송/수신 동작이 올바르게 진행되는지 검증한다.
+ 검증 후, 데이터를 수신 버퍼에 저장하면 어플리케이션이 Socket 라이브러리의 READ 함수를 호출하여
데이터를 어플리케이션에게 건네준다. 보통은 데이터 패킷이 도착하기 전, 어플리케이션이 READ를 호출하여
데이터의 도착을 기다리는 상태가 되는데, 이 경우 TCP 담당이 데이터 수신이 끝나는 것과 동시에 어플리케이션에
데이터를 건네주는 동작이 시작된다고 생각하면 된다.
+ 데이터 송/수신이 끝나면 서버측에서 Socket 라이브러리의 close 함수를 호출하여 연결을 종료한다.

## 웹 서버 소프트웨어가 리퀘스트 메시지의 의미를 해석하여 요구에 응한다.
+ 리퀘스트 메시지에는 메소드라는 일종의 명령과 데이터 출처를 나타내는 URI라는 경로명이 쓰여있고, 내용에 
따라 데이터를 클라이언트에게 응답한다.
+ 웹 서버가 Socket 라이브러리의 write 함수를 호출하여 응답 메시지를 프로토콜 스택에 건네준다. 
이 때 응답 메시지를 어디에 보내야 할지 프로토콜 스택에 알려주어야 하는데, 클라이언트를 직접 알려주는 것이
아니라 디스크립터를 통해 상대를 지정한다. 프로토콜 스택은 데이터를 한 개의 패킷에 들어가는 길이로 분할하고
헤더를 붙여 패킷을 전송한다. 이 패킷은 스위치나 라우터를 경유하여 인터넷 속을 통해 클라이언트에게 전달된다.
+ 클라이언트가 받은 응답 메시지는 LAN 어댑터가 신호로부터 디지털 데이터로 되돌리고, 프로토콜 스택이 
패킷을 모아 데이터를 추출하여 원래 응답 메시지로 되돌려서 브라우저에게 건네준다.
+ 브라우저는 헤더의 Content-Type이나 Content-Encoding 값을 통해 데이터의 종류를 판명하고
데이터 종류에 따라 화면 표시의 프로그램을 호출하여 데이터를 표시하면 된다.

















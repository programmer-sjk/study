# 1장. 웹 브라우저 
## 탐험 경유지
```text
1. HTTP 리퀘스트 메시지를 작성한다.
2. 웹 서버의 IP 주소를 DNS 서버에 조회한다.
3. 전 세계의 DNS 서버가 연대한다.
4. 프로토콜 스택에 메시지 송신을 의뢰한다.
```
### HTTP 리퀘스트 메시지를 작성한다.
### 웹 서버의 IP 주소를 DNS 서버에 조회한다.
+ 브라우저는 URL을 해독하거나 HTTP 메시지를 만들지만, 메시지를 네트워크에 송출하는 기능은 없으므로 OS에 의뢰하여 송신한다.
+ 이 때, URL에 쓰여있는 서버의 도메인명에서 IP 주소를 조사해야 한다. OS에 송신을 의뢰할 때는 도메인명이 아니라 IP 주소를 지정해야 하기 때문.
+ IP 주소를 조사하는 방법은 간단하다. 가장 가까운 DNS 서버에게 질문하는 것이다. 그렇다면 브라우저는 어떻게 DNS 서버를 조회할 수 있을까?
+ 브라우저는 리졸버를 호출하게 되는데, 여기에서 DNS 서버에 문의하기 위한 메시지를 만든다. 리졸버가 프로토콜 스택을 호출하면
메시지 보내는 동작을 실행하여 LAN 어댑터를 통해 메시지가 DNS로 송신된다.
+ 웹 서버가 DNS에 등록되어 있으면 네트워크를 통해 응답이 전송되고 프로토콜 스택을 경유하여 리졸버가 응답을 받는다.
리졸버는 IP 주소를 추출하고 제어권은 웹 브라우져에게 넘어간다.

### 전 세계의 DNS 서버가 연대한다.
+ DNS 서버는, 서버에 등록된 도메인명과 IP 주소의 대응표를 조사하여 IP 주소를 회답한다.
+ 인터넷에는 막대한 수의 서버가 있으므로 전부 1대의 DNS 서버에 등록하는 것은 불가능하다. 따라서 DNS 서버에 등록되지 않은
도메인을 찾는 경우도 발생한다. 이때는 정보를 분산시켜 다수의 DNS 서버의 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가
등록되어 있는지를 찾는 구조로 동작한다.
+ 인터넷에는 DNS 서버가 수만 대나 있으므로 닥치는대로 뒤지면서 다닐수는 없다. 그래서 다음과 같은 방법을 고안했다.
하위의 도메인을 담당하는 DNS 서버의 IP 주소를 상위 DNS 서버에 등록하고, 그 상위의 DNS 서버를 또 상위의 DNS 서버에 등록한다.
+ 즉, blog.inflearn.com 이라는 도메인을 담당하는 DNS 서버를 inflearn.com DNS 서버에 등록하고, inflearn.com의
DNS 서버를 com 도메인의 DNS 서버에 등록하는 식이다. 이렇게 하면 상위의 DNS에 가면 하위의 DNS 서버의 IP 주소를 알 수 있고
거기에서 조회 메시지를 보낼 수 있다.
+ 위의 설명에서는 com, kr 을 관리하는 DNS 서버에 하위 DNS 서버를 등록하는 것으로 끝나 보이지만,com, kr 상위에 
루트 도메인이 있다. 루트 도메인에 com, kr 등의 DNS 서버를 등록한다. 이렇게 해서 루트 도메인부터 차례로 아래로 거슬러
갈 수 있다.
+ 등록 작업은 한 가지 더 있는데, 루트 도메인의 DNS 서버를 인터넷에 존재하는 DNS 서버에 전부 등록하는 것이다.
이렇게 해서 어느 DNS 서버도 루트 도메인에 접속할 수 있게 된다. 결과적으로 클라이언트에서 가까운 DNS 서버에 엑세스하면
루트도메인을 경유하여 원하는 DNS 서버에 도착하게 된다.
+ 최상위 루트 도메인에서 따라간다는 원칙대로 움직이지 않을 수 도 있는데, DNS 서버는 한 번 조사한 이름은 캐시에 기록하기 때문에,
조회한 이름에 해당하는 정보가 캐시에 있다면 그 정보를 회답한다. 이 방법이 루트도메인 부터 찾는 방법보다 편리하다. 캐쉬의 주의점은
캐쉬에 등록 후 등록정보가 변경되는 경우가 있으므로, 캐시의 유효기한을 설정하고 유효기간이 지나면 삭제한다.

### 프로토콜 스택에 메시지 송신한다.
+ 클라이언트는 소켓을 생성하고 서버측의 소켓에 파이프를 연결한다. 데이터를 송, 수신 후에 소켓을 종료한다.
+ 위 동작을 실행하는 것은 OS 내부의 프로토콜 스택이다. 브라우저 등의 애플리케이션은 자체에서 파이프를 연결하지 않고
프로토콜 스택에 의뢰하여 파이프를 연결하거나 데이터를 쏟아붇는다.

# 2장. TCP/IP의 데이터를 전기 신호로 만들어 보낸다.
## 탐험 경유지
```text
1. 소켓을 작성 -> 서버에 접속 -> 데이터를 송/수신 -> 서버에서 연결을 끊어 소켓을 말소
2. IP와 이더넷의 패킷 송/수신 동작
3. UDP 프로토콜을 이용한 송/수신 동작
```

## 소켓을 작성한다.
+ 브라우저, 메일 SW, 웹 서버 등의 프로그램은 네트워크 애플리케이션으로 OS 프로토콜 스택에 데이터 송/수신을 의뢰한다.
+ 프로토콜 스택의 윗 부분에는 데이터 송/수신을 담당하는 TCP/UDP 프로토콜이 있다. 이 둘이 애플리케이션의 의로를 받아 송/수신 동작을 실행
+ 그 아래에는 IP 프로토콜을 사용하여 패킷 송/수신 동작을 제어한다. 인터넷에서 데이터를 운반할 때는 데이터를 패킷 단위로 작게 나누는데,
이 패킷을 통신 상대까지 운반하는 것이 IP의 주 역할.
+ IP 아래에 있는 LAN 드라이버는 LAN 어댑터의 하드웨어를 제어한다. LAN 어댑터가 실제 송/수신 동작, 즉 케이블에 대한 신호를 송출한다.
+ 프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 여기에 통신 동작을 제어하기 위한 제어 정보를 기록합니다. 
대표적으로는 IP, Port, 통신 동작의 진행 상태를 의미합니다. 본래 소켓은 개념적인 것으로 실체가 없으므로 굳이 말하자면
이 제어 정보가 소켓 정보의 실체라고 할 수 있다. 
+ 브라우저가 socket, connect 등의 Socket 라이브러리 API를 호출할 때 프로토콜 스택 내부의 모습을 보자. 애플리케이션이
socket을 호출하면 프로토콜 스택이 최초로 하는 일은 소켓 한 개 분량의 메모리를 확보하는 것이다. 소켓이 만들어지면 소켓을 가리키는
디스크립터를 애플리케이션에게 알려주고, 이 후 애플리케이션은 프로토콜 스택에 의뢰 시, 이 디스크립터를 전달한다.

## 서버에 접속한다.
+ 서버 접속의 첫 번째 동작은 통신 상대 사이에 제어 정보를 주고 받아, 데이터 송/수신이 가능한 상태로 만드는 것이다.
+ 접속 동작의 실체는 애플리케이션의 Socket의 connect를 호출하는 곳부터 시작된다. 서버측의 IP 주소와 포트 번호를 쓰면
프토토콜 스택의 TCP 담당 부분에 전달된다. 그러면 TCP 담당 부분은 서버의 TCP 담당 부분 사이의 제어 정보를 주고받는다.
+ 프로토콜 스택은 TCP 헤더를 만들고 (SYN) IP 담당에 건네주어 송신을 의뢰한다. 그러면 IP 담당이 패킷 송신 동작을 실행하고
네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당이 이걸 받아 TCP 담당에게 건네 준다.
+ 서버측의 TCP 담당은 TCP 헤더를 조사하여 수신처 포트 번호에 해당하는 소켓을 찾아낸다.SYN + ACK 컨트롤 비트를 만드는데, 
ACK은 패킷을 받은 것을 알리기 위한 동작이다. 이 TCP 헤더를 IP에 전달하여 클라이언트에게 응답한다.
+ 패킷은 클라이언트 측의 IP 담당을 경유하여 TCP 담당에 도착한다. 패킷이 도착한 것을 서버에 알리기 위해 ACK 비트를 1로 만든
TCP 헤더를 반송하고, 이것이 서버에 도착하면 접속 동작의 대화가 끝이난다.
+ 이로써 소켓은 데이터를 송/수신할 수 있는 상태가 되고, 커넥션이 이루어지면 프로토콜의 접속 동작이 끝나므로 애플리케이션에게
제어가 돌아온다.

## 데이터를 송/수신한다.
+ 프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 일단 내부에 있는 송신용 버퍼 메모리에 저장을 하고, 애플리케이션이 주는
다음 데이터를 기다린다. 전송하는 데이터의 사이즈는 애플리케이션에 의해 결정되기 때문에, 데이터를 곧바로 보내는 단순한 방법이라면
작은 패킷을 많이 보낼 수도 있다. 이렇게 되면 네트워크 이용 효율이 저하되므로 어느 정도 데이터를 저장하고 송신을 진행한다.
+ 데이터를 송신하는 기준은 아래 두 가지 정도가 있다. 하나는 한 패킷에 저장할 수 있는 데이터의 크기로 MTU라는 매개 변수로 판단한다.
데이터가 어느정도 채워지면 보내는 방법과, 애플리케이션이 느려지면 송신 동작이 지연되므로, 버퍼에 데이터가 모이지 않아도 적당한
타이밍에 송신 동작을 수행한다.
+ 전자를 중시하면 패킷 길이가 길어져 네트워크 이용 효율이 높아지지만, 버퍼에 머무는 시간만큼 송신 동작이 지연될 우려가 있다.
후자를 중시하면 지연은 적어지지만 이용효율이 떨어져서 양자를 절충해서 적당한 시간을 가늠해 송신을 해야 한다.
+ 또한 이것을 온전히 프로토콜 스택에 맡긴다면 좋지 않을 수 있어, 애플리케이션에서 송신의 타이밍을 제어하는 여지도 남겨두었다.
즉, 데이터 송신을 의뢰할 때 옵션을 지정하면, 버퍼에 머물지 않고 바로 전송을 하도록 할 수도 있다.
+ TCP에는 송신한 패킷을 상대에게 올바르게 도착했는지 확인하는 기능이 있는데 이 과정에 대해 알아보자.
+ 클라이언트에서는 서버로 보내는 데이터에 시퀀스 번호를 붙여 전달한다. 서버는 받은 시퀀스 값과, 이로부터 ACK 번호를 산출하여 
시퀀스, ACK 번호 모두를 클라이언트에게 반송한다. 클라이언트는 ACK 번호를 산출하여 서버에 반송하고, 이를 통해
데이터 송/수신 동작에 들어가게 된다.
+ TCP는 상대가 데이터를 받은 것을 확인하는데, 확인할 때까지 송신한 패킷을 송신용 버퍼 메모리 영역에 보관해둔다.
송신한 데이터에 해당하는 ACK 번호가 상대로부터 돌아오지 않으면 패킷을 다시 전달한다. 이 구조는 매우 강력하여 수신측에 패킷이
올바르게 도착한 것을 확인하고, 도착하지 않으면 다시 보내므로 네트워크 상의 어디든 오류가 발생헀더라도 그것을 검출하고 
패킷을 다시 보낼 수 있다.

## 서버에서 연결을 끊고 소켓을 말소한다.
+ 데이터 송/수신이 종료되는 것은 애플리케이션이 송신해야 하는 데이터를 전부 송신했다고 판단하는 때이다. 클라이언트 - 서버
로 예를 들면 서버가 데이터를 다 전달한 후 서버가 연결을 끊게 된다.
+ 서버측의 애플리케이션이 Socket 라이브러리의 close 함수를 호출한다. 서버측의 프로토콜 스택이 TCP 헤더를 만들고, 연결 끊기를
나타내는 정보(FIN)를 설정하고 IP 담당에 송신을 의뢰한다. 연결 종료 패킷을 받은 클라이언트 측의 프로토콜 스택은 해당 소켓에
연결 끊기 동작이 들어갔다는 것을 기록하고, 서버측으로 FIN 패킷을 받은 것을 알리기 위해 ACK 패킷을 전달한다. 그 후 클라이언트
측의 애플리케이션도 close 함수를 호출하여 데이터 송/수신 동작을 종료한다.

## IP와 이더넷의 패킷 송/수신 동작
+ 패킷의 송신처가 되는 기기가 패킷을 만드는데, 헤더에는 적절한 제어 정보를 기록하고 데이터 부분에는 데이터를 넣은 후 패킷을 가장
가까운 중계장치에 송신한다. 중계장치는 도착한 패킷의 헤더를 조사해 목적지를 판단하고 내부의 표와 비교해 패킷의 목적지를 판단한다.
예를 들어 패킷의 수선처와 표를 결합해서 xx 주소는 yy번째 케이블에 해당하는 것을 알았다면 yy번째 케이블에 패킷의 신호를 송신합니다.
+ IP 담당 부분은 패킷을 송출만 하기 때문에, 그 뒤에 상대에게 패킷을 운반하는 것은 허브나 라우터 같은 네트워크 기기의 역할. 
IP 담당은 TCP 헤더와 데이터를 한 덩어리의 바이너리 데이터로 간주하여 내용을 보지 않고 송/수신 동작을 실행한다.
송/수신 의뢰를 받으면 IP 헤더를 만들어 TCP 헤더의 앞에 붙인다. IP 헤더를 만들었으면 MAC 헤더를 붙인다.
IP 헤더는 목적지에 대한 제어 정보를 기록한 것이고, MAC 헤더는 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어 정보를 기록한 것. 
IP 담당의 역할은 두 헤더를 붙인 패킷을 만들고 네트워크용 하드웨어(LAN 카드 or LAN 어댑터 or 네트워크 카드)에게 패킷을 건네준다.
+ IP 헤더에는 패킷을 전달하는 목적지가 쓰여있고, 이것을 보면 패킷을 어디로 운반해야 하는지 판단할 수 있는데,
이더넷에는 TCP/IP 개념이 통용되지 않는다. 따라서 이더넷의 수신처 판단 구조로 사용하는 것이 MAC 헤더이다.
MAC 헤더를 IP 헤더 앞에 붙이면 패킷이 완성되며 여기까지가 IP 담당의 역할이다. LAN 어댑터에 건네주기 전에 IP 담당 부분에서
패킷을 완성하면 LAN 어댑터는 완성된 패킷만 송신하면 된다.
+ IP 담당 부분이 패킷을 완성했으면 LAN 어댑터가 나설 차례인데, 그 전에 이더넷의 기본에 대해 설명한다. 이더넷은 다수의
컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술이며 현재의 이더넷은 스위칭 허브를 사용한다.
송신처는 스위칭 허브에게 신호를 전달하고, 스위칭 허브는 수신처를 확인한 뒤 수신처에게 신호를 전달한다.
+ 이 LAN 어댑터에 건네줄 떄의 패킷의 모습은 0, 1의 비트가 이어진 디지털 데이터라고 생각하면 되고 이것이 LAN 어댑터에 의해
전기나 빛의 신호 상태로 바뀌어 케이블에 송출된다. 신호는 허브나 라우터 등의 중계 장치에 도착하고, 중계장치가 상대가 있는 곳까지
패킷을 전달한다.
+ 이더넷에서 패킷의 송/수신 동작은 IP가 만든 패킷을 전기나 빛의 신호로 변환하여 네트워크 케이블에 송출한다. 이 동작을 실행
하는 것이 LAN 어댑터이다.
+ LAN 드라이버는 IP 담당으로부터 패킷을 받으면 그것을 LAN 어댑터의 버퍼 메모리로 복사한다. 복사를 마친 후 패킷을
송신하도록 MAC 회로에 명령을 보내면, MAC 회로는 디지털 데이터의 0, 1 비트 값을 전압이나 전류의 값으로 대응시킨다.
신호에서 데이터를 읽을 떄의 동작은 반대로, 신호의 전압이나 전류의 값을 읽고 거기에 0, 1 비트 값으로 되돌리면 된다.
+ LAN 어댑터의 MAC 회로가 공통 형식의 신호를 만들고 PHY 회로가 케이블에 송출하는 형식으로 변환하여 케이블에 송신한다.
+ 스위칭 허브와 라우터를 거쳐서 전기 신호가 수신측으로 흘러 들어간다.

  




























# 1장. 웹 브라우저 
## 탐험 경유지
```text
1. HTTP 리퀘스트 메시지를 작성한다.
2. 웹 서버의 IP 주소를 DNS 서버에 조회한다.
3. 전 세계의 DNS 서버가 연대한다.
4. 프로토콜 스택에 메시지 송신을 의뢰한다.
```
### HTTP 리퀘스트 메시지를 작성한다.
### 웹 서버의 IP 주소를 DNS 서버에 조회한다.
+ 브라우저는 URL을 해독하거나 HTTP 메시지를 만들지만, 메시지를 네트워크에 송출하는 기능은 없으므로 OS에 의뢰하여 송신한다.
+ 이 때, URL에 쓰여있는 서버의 도메인명에서 IP 주소를 조사해야 한다. OS에 송신을 의뢰할 때는 도메인명이 아니라 IP 주소를 지정해야 하기 때문.
+ IP 주소를 조사하는 방법은 간단하다. 가장 가까운 DNS 서버에게 질문하는 것이다. 그렇다면 브라우저는 어떻게 DNS 서버를 조회할 수 있을까?
+ 브라우저는 리졸버를 호출하게 되는데, 여기에서 DNS 서버에 문의하기 위한 메시지를 만든다. 리졸버가 프로토콜 스택을 호출하면
메시지 보내는 동작을 실행하여 LAN 어댑터를 통해 메시지가 DNS로 송신된다.
+ 웹 서버가 DNS에 등록되어 있으면 네트워크를 통해 응답이 전송되고 프로토콜 스택을 경유하여 리졸버가 응답을 받는다.
리졸버는 IP 주소를 추출하고 제어권은 웹 브라우져에게 넘어간다.

### 전 세계의 DNS 서버가 연대한다.
+ DNS 서버는, 서버에 등록된 도메인명과 IP 주소의 대응표를 조사하여 IP 주소를 회답한다.
+ 인터넷에는 막대한 수의 서버가 있으므로 전부 1대의 DNS 서버에 등록하는 것은 불가능하다. 따라서 DNS 서버에 등록되지 않은
도메인을 찾는 경우도 발생한다. 이때는 정보를 분산시켜 다수의 DNS 서버의 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가
등록되어 있는지를 찾는 구조로 동작한다.
+ 인터넷에는 DNS 서버가 수만 대나 있으므로 닥치는대로 뒤지면서 다닐수는 없다. 그래서 다음과 같은 방법을 고안했다.
하위의 도메인을 담당하는 DNS 서버의 IP 주소를 상위 DNS 서버에 등록하고, 그 상위의 DNS 서버를 또 상위의 DNS 서버에 등록한다.
+ 즉, blog.inflearn.com 이라는 도메인을 담당하는 DNS 서버를 inflearn.com DNS 서버에 등록하고, inflearn.com의
DNS 서버를 com 도메인의 DNS 서버에 등록하는 식이다. 이렇게 하면 상위의 DNS에 가면 하위의 DNS 서버의 IP 주소를 알 수 있고
거기에서 조회 메시지를 보낼 수 있다.
+ 위의 설명에서는 com, kr 을 관리하는 DNS 서버에 하위 DNS 서버를 등록하는 것으로 끝나 보이지만,com, kr 상위에 
루트 도메인이 있다. 루트 도메인에 com, kr 등의 DNS 서버를 등록한다. 이렇게 해서 루트 도메인부터 차례로 아래로 거슬러
갈 수 있다.
+ 등록 작업은 한 가지 더 있는데, 루트 도메인의 DNS 서버를 인터넷에 존재하는 DNS 서버에 전부 등록하는 것이다.
이렇게 해서 어느 DNS 서버도 루트 도메인에 접속할 수 있게 된다. 결과적으로 클라이언트에서 가까운 DNS 서버에 엑세스하면
루트도메인을 경유하여 원하는 DNS 서버에 도착하게 된다.
+ 최상위 루트 도메인에서 따라간다는 원칙대로 움직이지 않을 수 도 있는데, DNS 서버는 한 번 조사한 이름은 캐시에 기록하기 때문에,
조회한 이름에 해당하는 정보가 캐시에 있다면 그 정보를 회답한다. 이 방법이 루트도메인 부터 찾는 방법보다 편리하다. 캐쉬의 주의점은
캐쉬에 등록 후 등록정보가 변경되는 경우가 있으므로, 캐시의 유효기한을 설정하고 유효기간이 지나면 삭제한다.

### 프로토콜 스택에 메시지 송신한다.
+ 클라이언트는 소켓을 생성하고 서버측의 소켓에 파이프를 연결한다. 데이터를 송, 수신 후에 소켓을 종료한다.
+ 위 동작을 실행하는 것은 OS 내부의 프로토콜 스택이다. 브라우저 등의 애플리케이션은 자체에서 파이프를 연결하지 않고
프로토콜 스택에 의뢰하여 파이프를 연결하거나 데이터를 쏟아붇는다.

# 2장. TCP/IP의 데이터를 전기 신호로 만들어 보낸다.
## 탐험 경유지
```text
1. 소켓을 작성 -> 서버에 접속 -> 데이터를 송/수신 -> 서버에서 연결을 끊어 소켓을 말소
2. IP와 이더넷의 패킷 송/수신 동작
3. UDP 프로토콜을 이용한 송/수신 동작
```

## 소켓을 작성한다.
+ 브라우저, 메일 SW, 웹 서버 등의 프로그램은 네트워크 애플리케이션으로 OS 프로토콜 스택에 데이터 송/수신을 의뢰한다.
+ 프로토콜 스택의 윗 부분에는 데이터 송/수신을 담당하는 TCP/UDP 프로토콜이 있다. 이 둘이 애플리케이션의 의로를 받아 송/수신 동작을 실행
+ 그 아래에는 IP 프로토콜을 사용하여 패킷 송/수신 동작을 제어한다. 인터넷에서 데이터를 운반할 때는 데이터를 패킷 단위로 작게 나누는데,
이 패킷을 통신 상대까지 운반하는 것이 IP의 주 역할.
+ IP 아래에 있는 LAN 드라이버는 LAN 어댑터의 하드웨어를 제어한다. LAN 어댑터가 실제 송/수신 동작, 즉 케이블에 대한 신호를 송출한다.
+ 프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 여기에 통신 동작을 제어하기 위한 제어 정보를 기록합니다. 
대표적으로는 IP, Port, 통신 동작의 진행 상태를 의미합니다. 본래 소켓은 개념적인 것으로 실체가 없으므로 굳이 말하자면
이 제어 정보가 소켓 정보의 실체라고 할 수 있다. 
+ 브라우저가 socket, connect 등의 Socket 라이브러리 API를 호출할 때 프로토콜 스택 내부의 모습을 보자. 애플리케이션이
socket을 호출하면 프로토콜 스택이 최초로 하는 일은 소켓 한 개 분량의 메모리를 확보하는 것이다. 소켓이 만들어지면 소켓을 가리키는
디스크립터를 애플리케이션에게 알려주고, 이 후 애플리케이션은 프로토콜 스택에 의뢰 시, 이 디스크립터를 전달한다.

## 서버에 접속한다.
+ 서버 접속의 첫 번째 동작은 통신 상대 사이에 제어 정보를 주고 받아, 데이터 송/수신이 가능한 상태로 만드는 것이다.
+ 접속 동작의 실체는 애플리케이션의 Socket의 connect를 호출하는 곳부터 시작된다. 서버측의 IP 주소와 포트 번호를 쓰면
프토토콜 스택의 TCP 담당 부분에 전달된다. 그러면 TCP 담당 부분은 서버의 TCP 담당 부분 사이의 제어 정보를 주고받는다.
+ 프로토콜 스택은 TCP 헤더를 만들고 (SYN) IP 담당에 건네주어 송신을 의뢰한다. 그러면 IP 담당이 패킷 송신 동작을 실행하고
네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당이 이걸 받아 TCP 담당에게 건네 준다.
+ 서버측의 TCP 담당은 TCP 헤더를 조사하여 수신처 포트 번호에 해당하는 소켓을 찾아낸다.SYN + ACK 컨트롤 비트를 만드는데, 
ACK은 패킷을 받은 것을 알리기 위한 동작이다. 이 TCP 헤더를 IP에 전달하여 클라이언트에게 응답한다.
+ 패킷은 클라이언트 측의 IP 담당을 경유하여 TCP 담당에 도착한다. 패킷이 도착한 것을 서버에 알리기 위해 ACK 비트를 1로 만든
TCP 헤더를 반송하고, 이것이 서버에 도착하면 접속 동작의 대화가 끝이난다.
+ 이로써 소켓은 데이터를 송/수신할 수 있는 상태가 되고, 커넥션이 이루어지면 프로토콜의 접속 동작이 끝나므로 애플리케이션에게
제어가 돌아온다.

## 데이터를 송/수신한다.
+ 프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 일단 내부에 있는 송신용 버퍼 메모리에 저장을 하고, 애플리케이션이 주는
다음 데이터를 기다린다. 전송하는 데이터의 사이즈는 애플리케이션에 의해 결정되기 때문에, 데이터를 곧바로 보내는 단순한 방법이라면
작은 패킷을 많이 보낼 수도 있다. 이렇게 되면 네트워크 이용 효율이 저하되므로 어느 정도 데이터를 저장하고 송신을 진행한다.
+ 데이터를 송신하는 기준은 아래 두 가지 정도가 있다. 하나는 한 패킷에 저장할 수 있는 데이터의 크기로 MTU라는 매개 변수로 판단한다.
데이터가 어느정도 채워지면 보내는 방법과, 애플리케이션이 느려지면 송신 동작이 지연되므로, 버퍼에 데이터가 모이지 않아도 적당한
타이밍에 송신 동작을 수행한다.
+ 전자를 중시하면 패킷 길이가 길어져 네트워크 이용 효율이 높아지지만, 버퍼에 머무는 시간만큼 송신 동작이 지연될 우려가 있다.
후자를 중시하면 지연은 적어지지만 이용효율이 떨어져서 양자를 절충해서 적당한 시간을 가늠해 송신을 해야 한다.
+ 또한 이것을 온전히 프로토콜 스택에 맡긴다면 좋지 않을 수 있어, 애플리케이션에서 송신의 타이밍을 제어하는 여지도 남겨두었다.
즉, 데이터 송신을 의뢰할 때 옵션을 지정하면, 버퍼에 머물지 않고 바로 전송을 하도록 할 수도 있다.
+ TCP에는 송신한 패킷을 상대에게 올바르게 도착했는지 확인하는 기능이 있는데 이 과정에 대해 알아보자.
+ 클라이언트에서는 서버로 보내는 데이터에 시퀀스 번호를 붙여 전달한다. 서버는 받은 시퀀스 값과, 이로부터 ACK 번호를 산출하여 
시퀀스, ACK 번호 모두를 클라이언트에게 반송한다. 클라이언트는 ACK 번호를 산출하여 서버에 반송하고, 이를 통해
데이터 송/수신 동작에 들어가게 된다.
+ TCP는 상대가 데이터를 받은 것을 확인하는데, 확인할 때까지 송신한 패킷을 송신용 버퍼 메모리 영역에 보관해둔다.
송신한 데이터에 해당하는 ACK 번호가 상대로부터 돌아오지 않으면 패킷을 다시 전달한다. 이 구조는 매우 강력하여 수신측에 패킷이
올바르게 도착한 것을 확인하고, 도착하지 않으면 다시 보내므로 네트워크 상의 어디든 오류가 발생헀더라도 그것을 검출하고 
패킷을 다시 보낼 수 있다.
















